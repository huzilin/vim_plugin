#!/usr/bin/env python
# -*- coding: UTF-8 -*-

import sys
import getopt
import MySQLdb
import commands
import multiprocessing
import time
import re


def usage():

    print("Usage:%s [-u|-p|-h|-P|-D|-t] [--help|--alter|--execute|--clean|--charset] args...." % sys.argv[0])


def get_table_info(host, port, user, passwd, db, table, charset):

    instance = dict()
    try:
        conn = MySQLdb.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)
        cursor = conn.cursor()
        sql = "dbscale show table location " + table
        n = cursor.execute(sql)

        for each in cursor.fetchall():
            instance.setdefault((each[1], int(each[2])), (each[5], int(each[6])))
        cursor.close()

        print "Get instance's info."
        return instance
    except MySQLdb.Error:
        return 0


def block_table(host, port, user, passwd, db, table, charset, block_or_unblock):

    instance = list()
    try:
        conn = MySQLdb.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)
        cursor = conn.cursor()
        if block_or_unblock == 'BLOCK':
            sql = "DBSCALE BLOCK TABLE " + table + " ALL 360"
        elif block_or_unblock == 'UNBLOCK':
            sql = "DBSCALE STOP BLOCK TABLE " + table

        n = cursor.execute(sql)
        cursor.close()
        return 1
    except MySQLdb.Error:
        print "Block Faile."
        return 0


def alter_worker(cmd_and_instance_info_queue, return_queue):

    cmd_and_instance_info = cmd_and_instance_info_queue.get()
    cmd, master_host, master_port, slave_host, slave_port, user, passwd, database, charset, table = cmd_and_instance_info
    (status, output) = commands.getstatusoutput(cmd)

    if status == 0:
        conn = MySQLdb.connect(host=master_host, port=master_port, user=user, passwd=passwd, db=database, charset=charset)
        cursor = conn.cursor()
        desc_sql = "desc " + table
        n = cursor.execute(desc_sql)
        new_table_struct = cursor.fetchall()
        cursor.close()

        conn = MySQLdb.connect(host=slave_host, port=slave_port, user=user, passwd=passwd, db=database, charset=charset)
        cursor = conn.cursor()
        while 1:
            desc_sql = "desc " + table
            show_slave_status_sql = "show slave status"
            cursor.execute(show_slave_status_sql)
            seconds = cursor.fetchall()[0][32]
            cursor.execute(desc_sql)
            slave_table_struct = cursor.fetchall()
            if slave_table_struct == new_table_struct:
                return_queue.put(0)
                break
            elif seconds == 0:
                print "Host:%s\tPort:%s\n%s slave may have something wrong with replication, didn't recived alter command." % (master_host, master_port, output)
                return_queue.put(master_host + " " + str(master_port))
            else:
                time.sleep(10)
        
        cursor.close()

    else:
        print "Host:%s\tPort:%s\n%s" % (master_host, master_port, output)
        return_queue.put(master_host + " " + str(master_port))


def match_table(host, port, user, passwd, db, table, charset, match_word):

    try:
        conn = MySQLdb.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)
        cursor = conn.cursor()
        sql = "show tables"
        n = cursor.execute(sql)

        match_table = list()
        for each in cursor.fetchall():
            table_name = re.compile(match_word)
            match = table_name.search(each[0])
            if match:
                match_table.append(match.group())

        cursor.close()
        return match_table
    except MySQLdb.Error:
        return 0


def drop_tables(host, port, user, passwd, db, charset, table_list):

    try:
        conn = MySQLdb.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)
        cursor = conn.cursor()
        for each in table_list:
            if each != "":
                sql = "drop table " + each
                n = cursor.execute(sql)
        cursor.close()
        return 1
    except MySQLdb.Error:
        return 0


def drop_triggers(host, port, user, passwd, db, charset, trigger_list):

    try:
        conn = MySQLdb.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)
        cursor = conn.cursor()
        for each in trigger_list:
            if each != "":
                sql = "drop trigger " + each
                n = cursor.execute(sql)
        cursor.close()
        return 1
    except MySQLdb.Error:
        return 0


def match_triggers(host, port, user, passwd, db, charset, match_word_list):

    try:
        conn = MySQLdb.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)
        cursor = conn.cursor()
        sql = "show triggers"
        n = cursor.execute(sql)

        match_trigger = list()

        for each in cursor.fetchall():
            for each_match_word in match_word_list:
                table_name = re.compile(each_match_word)
                match = table_name.search(each[0])
                if match:
                    match_trigger.append(match.group())

        cursor.close()
        return match_trigger
    except MySQLdb.Error:
        return 0


def rollback_operating(host, port, user, passwd, db, charset, table, old_table_name):

    try:
        conn = MySQLdb.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)
        cursor = conn.cursor()

        sql = "show tables"
        cursor.execute(sql)

        for each in cursor.fetchall():
            match_word = "^" + table + "$"
            table_match = re.compile(match_word)
            match = table_match.search(each[0])
            if match:
                sql = "drop table " + table
                cursor.execute(sql)

        sql = "rename table " + old_table_name[0] + " to " + table
        cursor.execute(sql)

        cursor.close()
        return 1

    except MySQLdb.Error:
        return 0


def cleaner_worker(instance_info_queue, clean_return_queue):

    instance_info = instance_info_queue.get()
    (host, port, user, passwd, database, table, charset, error_flag) = instance_info

    old_table_match = "_+" + table + "_old"
    old_table_name = match_table(host, port, user, passwd, database, table, charset, old_table_match)

    if old_table_name == 0:
        clean_return_queue.put([host, port, 101])
        return 101

    if len(old_table_name) > 0 and error_flag == 1:

        rollback_return = rollback_operating(host, port, user, passwd, database, charset, table, old_table_name)

        if rollback_return == 0:
            clean_return_queue.put([host, port, 102])
            return 102

        trigger_prefix = "pt_osc_" + database + "_" + table + "_"
        trigger_match_list = [trigger_prefix + "ins", trigger_prefix + "del", trigger_prefix + "upd"]
        drop_trigger_list = match_triggers(host, port, user, passwd, database, charset, trigger_match_list)

        if drop_trigger_list == 0:
            clean_return_queue.put([host, port, 103])
            return 103

        drop_triggers_return = drop_triggers(host, port, user, passwd, database, charset, drop_trigger_list)

        if drop_triggers_return == 0:
            clean_return_queue.put([host, port, 104])
            return 104

    else:
        new_table_match = "^" + table + "_new"
        new_table_name = match_table(host, port, user, passwd, database, table, charset, new_table_match)

        if new_table_name == 0:
            clean_return_queue.put([host, port, 105])
            return 105

        trigger_prefix = "pt_osc_" + database + "_" + table + "_"
        trigger_match_list = [trigger_prefix + "ins", trigger_prefix + "del", trigger_prefix + "upd"]
        drop_trigger_list = match_triggers(host, port, user, passwd, database, charset, trigger_match_list)

        if drop_trigger_list == 0:
            clean_return_queue.put([host, port, 103])
            return 103

        if len(old_table_name) > 0:

            drop_table_list = new_table_name + old_table_name

        else:

            drop_table_list = new_table_name

        drop_triggers_return = drop_triggers(host, port, user, passwd, database, charset, drop_trigger_list)

        if drop_triggers_return == 0:
            clean_return_queue.put([host, port, 104])
            return 104

        if len(drop_table_list) > 0:
            drop_tables_return = drop_tables(host, port, user, passwd, database, charset, drop_table_list)

            if drop_tables_return == 0:
                clean_return_queue.put([host, port, 106])
                return 106

    clean_return_queue.put(0)
    return 0


def clean_operating(dbscale_host, dbscale_port, user, passwd, database, table, charset, instance_num, instance_info, error_flag):

    #clean or rollback
    instance_info_queue = multiprocessing.Queue(instance_num)
    clean_return_queue = multiprocessing.Queue(instance_num)

    error_dic = {101: "Got error when matching old table.", 102: "Got error when doing rollback.", 103: "Got error when matching triggers.", 104: "Got error when matching drop triggers.", 105: "Got error when matching matching new table.", 106: "Got error when matching drop_tables."}

    process = list()

    #Maybe partition master crash down, wait few seconds for dbscale get a new topology.
    for host, port in instance_info:
        instance_info_queue.put((host, port, user, passwd, database, table, charset, error_flag))

    for each in range(instance_num):
        process.append(multiprocessing.Process(target=cleaner_worker, args=(instance_info_queue, clean_return_queue,)))

    for each in process:
        each.start()

    for each in process:
        each.join()

    return_list = list()

    for each in range(instance_num):
        return_list.append(clean_return_queue.get())

    error_flag = 0

    for each in return_list:
        if each != 0:
            print "Host:%s\tPort:%s\tError:%s" % (each[0], each[1], error_dic[each[2]])
            error_flag += 1

    if error_flag > 0:
        return 0
    else:
        return 1

if "__main__" == __name__:

    execute = 0
    clean = 0
    rollback = 0

    charset = 'utf8'

    try:
        opts, args = getopt.getopt(sys.argv[1:], "h:P:u:p:D:t:", ["help", "output=", "alter=", "execute", "clean", "rollback", "charset="])
        for opt, arg in opts:
            if opt == ("--help"):
                usage()
                sys.exit(1)
            elif opt == ("-h"):
                dbscale_host = arg
            elif opt == ("-P"):
                dbscale_port = int(arg)
            elif opt == ("-u"):
                user = arg
            elif opt == ("-p"):
                passwd = arg
            elif opt == ("-D"):
                database = arg
            elif opt == ("-t"):
                table = arg
            elif opt == ("--execute"):
                execute = 1
            elif opt == ("--clean"):
                clean = 1
            elif opt == ("--rollback"):
                rollback = 1
            elif opt == ("--charset"):
                charset = arg
            elif opt == ("--alter"):
                alter = arg

    except getopt.GetoptError:
        print("getopt error!")
        usage()
        sys.exit(1)

    if (execute + clean + rollback) == 0 or (execute + clean + rollback) > 1:
        usage()
        sys.exit(1)

    #start handle
    import pdb
    pdb.set_trace()

    if execute == 1:
        instance_info = get_table_info(dbscale_host, dbscale_port, user, passwd, database, table, charset)
        instance_num = len(instance_info)

        with open('part_count', 'w') as pc:
            pc.write(str(instance_num))

        with open('table_before_swap_count', 'w') as tbsc:
            tbsc.write('0')

        with open('block_flag', 'w') as bf:
            bf.write('0')

        error_flag = 0

        clean_operating(dbscale_host, dbscale_port, user, passwd, database, table, charset, instance_num, instance_info.keys(), error_flag)

        #start alter
        process = list()

        cmd_and_instance_info_queue = multiprocessing.Queue(instance_num)
        return_queue = multiprocessing.Queue(instance_num)

        for (master_host, master_port), (slave_host, slave_port) in instance_info.items():
            cmd_and_db_info = ["pt-online-schema-change --alter \"" + alter + "\" --execute --nodrop-old-table D=" + database + ",t=" + table + " -h" + master_host + " -u" + user + " -p" + passwd + " -P" + str(master_port) + " --new-table-name=" + table + "_new --plugin bst.pm", master_host, master_port, slave_host, slave_port, user, passwd, database, charset, table]
            cmd_and_instance_info_queue.put(cmd_and_db_info)

        for each in range(instance_num):
            process.append(multiprocessing.Process(target=alter_worker, args=(cmd_and_instance_info_queue, return_queue)))

        for each in process:
            each.start()

        before_swap_count = 0
        before_swap_error = 0
        while before_swap_count != instance_num:
            #check how many part already been before swap table
            with open('table_before_swap_count', 'r') as tbsc:
                before_swap_count = int(tbsc.read())
            time.sleep(10)

            #check return
            if return_queue.qsize() != 0:

                print "An error occurred on:",
                for each in range(return_queue.qsize()):
                    print return_queue.get(),

                for each in process:
                    each.terminate()

                for each in process:
                    each.join()

                print "Execute Pt-osc Failed!"
                before_swap_error = 1
                break

        #if have error then rollback
        if before_swap_error == 1:

            instance_new_info = get_table_info(dbscale_host, dbscale_port, user, passwd, database, table, charset)

            clean_operating(dbscale_host, dbscale_port, user, passwd, database, table, charset, instance_num, instance_new_info.keys(), error_flag)

            print "All have been rollback."
            sys.exit(1)

        print "All BEFORE SWAP."

        block_table(dbscale_host, dbscale_port, user, passwd, database, table, charset, 'BLOCK')
        with open('block_flag', 'w') as bf:
            bf.write('1')
        print "Table has been block."

        get_times = 0
        while get_times < instance_num:
            if return_queue.qsize() > 0:
                alter_return = return_queue.get()
                if alter_return != 0:
                    print "An error occurred on:%s" % alter_return
                    for each in process:
                        each.terminate()
                    error_flag = 1
                    break
                get_times += 1
            else:
                time.sleep(5)

        for each in process:
            each.join()

        if error_flag == 1:
            print "Rollback in 15 seconds."
            time.sleep(15)
        else:
            print "Alter Successful."

        clean_retry = 0

        while clean_retry < 3:
            try:
                instance_new_info = get_table_info(dbscale_host, dbscale_port, user, passwd, database, table, charset)

                clean_return = clean_operating(dbscale_host, dbscale_port, user, passwd, database, table, charset, instance_num, instance_new_info.keys(), error_flag)
                if clean_return == 0:
                    continue
                break
            except MySQLdb.Error:
                print "A server crash down when cleaning."
                clean_retry += 1
                time.sleep(10)

        if clean_retry == 3:
            print "Clean failed.Try to run dbscale_online-schema-change.py with \"--clean.\""

        block_return = block_table(dbscale_host, dbscale_port, user, passwd, database, table, charset, 'UNBLOCK')

        if block_return == 0:
            time.sleep(10)
            block_return = block_table(dbscale_host, dbscale_port, user, passwd, database, table, charset, 'UNBLOCK')
            if block_return == 0:
                print "Unblock Failed."
                sys.exit(1)

        print "All Clean."

    if clean == 1:

        instance_info = get_table_info(dbscale_host, dbscale_port, user, passwd, database, table, charset)
        instance_num = len(instance_info)

        error_flag = 0

        clean_return = clean_operating(dbscale_host, dbscale_port, user, passwd, database, table, charset, instance_num, instance_info.keys(), error_flag)

        if clean_return == 0:
            print "Got error when doing clean operating."

        #return to os error.
            sys.exit(1)

        block_return = block_table(dbscale_host, dbscale_port, user, passwd, database, table, charset, 'UNBLOCK')

        if block_return == 0:
            time.sleep(10)
            block_return = block_table(dbscale_host, dbscale_port, user, passwd, database, table, charset, 'UNBLOCK')
            if block_return == 0:
                print "Unblock Failed."
                sys.exit(1)

        print "Clean sucssesful."

    if rollback == 1:

        instance_info = get_table_info(dbscale_host, dbscale_port, user, passwd, database, table, charset)
        instance_num = len(instance_info)

        error_flag = 1

        clean_return = clean_operating(dbscale_host, dbscale_port, user, passwd, database, table, charset, instance_num, instance_info.keys(), error_flag)

        if clean_return == 0:
            print "Got error when doing clean operating."

        #return to os error.
            sys.exit(1)

        block_return = block_table(dbscale_host, dbscale_port, user, passwd, database, table, charset, 'UNBLOCK')

        if block_return == 0:
            time.sleep(10)
            block_return = block_table(dbscale_host, dbscale_port, user, passwd, database, table, charset, 'UNBLOCK')
            if block_return == 0:
                print "Unblock Failed."
                sys.exit(1)

        print "Rollback sucssesful."
