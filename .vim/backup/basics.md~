# C++基础
## 数据类型

### 基本的内置类型

下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。

|类型|	位|
|---:|---:|
|char|	1 个字节|
|unsigned char|	1 个字节|
|signed char	|1 个字节|
|int	|4 个字节|
|unsigned int|	4 个字节|
|signed int	|4 个字节|
|short int|	2 个字节|
|unsigned short int|	Range|
|signed short int	|Range|
|long int|	4 个字节|
|signed long int	|4 个字节|
|Lunsigned long int|	4 个字节|
|float	|4 个字节|
|double	|8 个字节|
|long double|	8 个字节|
|wchar_t|	2 或 4 个字节|

### typedef 声明

您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：
```cpp
typedef type newname;
```

例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：
```cpp
typedef int feet;
```
### 枚举类型
枚举类型声明一个可选的类型名称和一组标识符，用来作为该类型的值。的带有零个或多个标识符可以被用来作为该类型的值。每个枚举数是一个枚举类型的常数。
创建枚举，需要使用关键字 enum。枚举类型的一般形式为：
```cpp
enum enum-name { list of names } var-list;
```

```cpp
enum color { red, green=5, blue };
color c=green;
cout << c;
```
***

## C++ 变量作用域

### 全局变量

在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。
全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：
在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。


### 初始化局部变量和全局变量

当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：

|数据类型	|初始化默认值|
|---:|---:|
|int|	0|
|char|	'\0'|
|float|	0|
|double|	0|
|pointer|	NULL|

## 常量

### 整数常量

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。
整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。
后缀可以是大写，也可以是小写，U 和 L 的顺序任意。
```cpp
85         // 十进制
0213       // 八进制
0x4b       // 十六进制
30         // 整数
30u        // 无符号整数
30l        // 长整数
30ul       // 无符号长整数
```

### 浮点常量

浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。
当使用小数形式表示时，必须包含小数点、指数，或同时包含两者。当使用指数形式表示时，必须包含整数部分、小数部分，或同时包含两者。带符号的指数是用 e 或 E 引入的。
```cpp
v3.14159      // 合法的
314159E-5L    // 合法的
510E          // 非法的：不完整的指数
210f          // 非法的：没有小数或指数
.e55          // 非法的：缺少整数或分数
```

### 布尔常量

```cpp
true 值代表真。
false 值代表假。
```

### 字符常量

字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 char 类型的简单变量中。
字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。
在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：

|转义序列|含义|
|---:|---:|
|\\	|\ 字符|
|\'	|' 字符|
|\"	|" 字符|
|\?	|? 字符|
|\a	|警报铃声|
|\b	|退格键|
|\f	|换页符|
|\n	|换行符|
|\r	|回车|
|\t	|水平制表符|
|\v	|垂直制表符|
|\ooo	|一到三位的八进制数|
|\xhh . . .	|一个或多个数字的十六进制数|

### 字符串常量

字符串字面值或常量是括在双引号 "" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。
使用空格做分隔符，把一个很长的字符串常量进行分行。
下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。

```cpp
"hello, dear"
"hello, \
dear"
"hello, " "d" "ear"
```

### 定义常量

在 C++ 中，有两种简单的定义常量的方式：
1. 使用 #define 预处理器。
2. 使用 const 关键字。

### #define 预处理器

#### 格式

```cpp
#define identifier value
```

#### 示例

```cpp
#include <iostream>
using namespace std;
#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'
int main()
{
   int area;  

   area = LENGTH * WIDTH;
   cout << area;
   cout << NEWLINE;
   return 0;
}
```

### const 关键字

#### 格式

```cpp
const type variable = value;
```

#### 示例

```cpp
#include <iostream>
using namespace std;
int main()
{
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area;  

   area = LENGTH * WIDTH;
   cout << area;
   cout << NEWLINE;
   return 0;
}
```


## 修饰符类型

C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。
下面列出了数据类型修饰符：

1. signed
2. unsigned
3. long
4. short

|整型         |   signed unsigned long  short|
|---:|---:|
|字符型       | signed unsigned|
|双精度型     |long|
|long short    |signed unsigned |

例如：unsigned long int。

### 类型限定符

类型限定符提供了变量的额外信息。

|限定符	    |含义|
|---:|---:|
|const	    |const 类型的对象在程序执行期间不能被修改改变。|
|volatile   |    修饰符 volatile 告诉编译器，变量的值可能以程序未明确指定的方式被改变。|
|restrict   |    由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。|


## C++ 存储类

### auto 存储类

```cpp
auto 存储类是所有局部变量默认的存储类。
{
   int mount;
   auto int month;
}
```

上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。

### register 存储类

```cpp
register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。
{
   register int  miles;
}
```

寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

### static 存储类

static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。
static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。

```cpp
#include <iostream>

// 函数声明
void func(void);

static int count = 10; /* 全局变量 */

int main()
{
    while(count--)
    {
       func();
    }
    return 0;
}
// 函数定义
void func( void )
{
    static int i = 5; // 局部静态变量
    i++;
    std::cout << "变量 i 为 " << i ;
    std::cout << " , 变量 count 为 " << count << std::endl;
}
```

```
变量 i 为 6 , 变量 count 为 9
变量 i 为 7 , 变量 count 为 8
变量 i 为 8 , 变量 count 为 7
变量 i 为 9 , 变量 count 为 6
变量 i 为 10 , 变量 count 为 5
变量 i 为 11 , 变量 count 为 4
变量 i 为 12 , 变量 count 为 3
变量 i 为 13 , 变量 count 为 2
变量 i 为 14 , 变量 count 为 1
变量 i 为 15 , 变量 count 为 0
```

### extern 存储类

extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。
当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。
extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：

第一个文件：main.cpp

```cpp
#include <iostream>

int count ;
extern void write_extern();

int main()
{
   count = 5;
   write_extern();
}
```

第二个文件：support.cpp

```cpp
#include <iostream>

extern int count;

void write_extern(void)
{
   std::cout << "Count is " << count << std::endl;
}
```

在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：

```shell
$ g++ main.cpp support.cpp -o write
```

这会产生 write 可执行程序，尝试执行 write，它会产生下列结果：

```shell
$ ./write
Count is 5
```

### mutable 存储类

mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。

## 运算符

### 位运算符

A = 0011 1100
B = 0000 1101

<html>
 <head></head>
 <body>
  <table>
   <tbody>
    <tr>
     <td ><strong>运算符</strong></td>
     <td ><strong>描述</strong></td>
     <td ><strong>实例</strong></td>
    </tr>
    <tr>
     <td >&amp;</td>
     <td >如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>
     <td >(A &amp; B) 将得到 12，即为 0000 1100</td>
    </tr>
    <tr>
     <td >|</td>
     <td >如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>
     <td >(A | B) 将得到 61，即为 0011 1101</td>
    </tr>
    <tr>
     <td >^</td>
     <td >如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>
     <td >(A ^ B) 将得到 49，即为 0011 0001</td>
    </tr>
    <tr>
     <td >~</td>
     <td >二进制补码运算符是一元运算符，具有&quot;翻转&quot;位效果。</td>
     <td >&nbsp;(~A ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。</td>
    </tr>
    <tr>
     <td >&lt;&lt;</td>
     <td >二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
     <td >A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
    </tr>
    <tr>
     <td >&gt;&gt;</td>
     <td >二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>
     <td >A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
    </tr>
   </tbody>
  </table>
 </body>
</html>

### 杂项运算符

|运算符|	描述|
|---:|---:|
|sizeof	|sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。|
|Condition ? X : Y	|条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。|
|,	|逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。|
|.（点）和 ->（箭头）	|成员运算符用于引用类、结构和共用体的成员。|
|Cast	|强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。|
|&	|指针运算符 & 返回变量的地址。例如 &a; 将给出变量的实际地址。|
|*	|指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。|

## 循环


### While

```cpp
while(condition)
{
   statement(s);
}
```

### for

```cpp
for ( init; condition; increment )
{
   statement(s);
}
```

#### for的无限循环写法

```cpp
for( ; ; )
```

### do...while

```cpp
do
{
   statement(s);
}while( condition );
```

### goto

#### 语法

```cpp
goto label;
..
.
label: statement;
```

#### 示例

```cpp
LOOP:do
{
    if( a == 15)
    {
       // 跳过迭代
       a = a + 1;
       goto LOOP;
    }
    cout << "a 的值：" << a << endl;
    a = a + 1;
}while( a < 20 );
```

## 判断

### if

```cpp
if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句
}
else
{
   // 如果布尔表达式为假将执行的语句
}
```

### switch

```cpp
switch(expression){
    case constant-expression  :
       statement(s);
       break; // 可选的
    case constant-expression  :
       statement(s);
       break; // 可选的

    // 您可以有任意数量的 case 语句
    default : // 可选的
       statement(s);
}
```

### ? : 运算符

? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。

```cpp
Exp1 ? Exp2 : Exp3;
```

## 函数

### 定义函数

```cpp
return_type function_name( parameter list )
{
   body of the function
}
```

### 声明函数

```cpp
int max(int num1, int num2);
//在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明
int max(int, int);
```


### 函数参数

#### 指针调用

##### 定义

```cpp
// 函数定义
void swap(int *x, int *y)
{
   int temp;
   temp = *x;	/* 保存地址 x 的值 */
   *x = *y;		/* 把 y 赋值给 x */
   *y = temp;	/* 把 x 赋值给 y */

   return;
}
```

##### 调用

```cpp
swap(&a, &b);
```

#### 引用调用

```cpp
// 函数定义
void swap(int &x, int &y)
{
   int temp;
   temp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y  */

   return;
}
```

##### 调用

```cpp
swap(a, b);
```

## 数组

### 声明数组

```cpp
type arrayName [ arraySize ];
```

### 初始化数组

#### 逐个初始化

```cpp
balance[4] = 50.0;
```

#### 统一初始化

```cpp
double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
```

#### 数组的大小则为初始化时元素的个数。

```cpp
double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};
```

### 多维数组

```cpp
type name[size1][size2]...[sizeN];
```

### 指向数组的指针

balance 是一个指向 &balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 p 赋值为 balance 的第一个元素的地址：

```cpp
double *p;
double balance[10];
p = balance;
```

数组名作为常量指针是合法的    *(balance + 4) 访问 balance[4] 数据
*p、*(p+1)、*(p+2) 等来访问数组元素

#### 使用p遍历

```cpp
for ( int i = 0; i <5; i++ )
{
    printf("*(p + %d) : %f\n",  i, *(p + i) );
}
```

#### 使用数组名作为指针遍历

```cpp
for ( int i = 0; i < 5; i++ )
{
    printf("*(balance + %d) : %f\n",  i, *(balance + i) );
}
```

### 传递数组给函数

#### 方式 1    形参是指针

```cpp
void myFunction(int *param)
{
.
.
.
}
```

#### 方式 2    形参是定长数组

```cpp
void myFunction(int param[10])
{
.
.
.
}
```

#### 方式 3    形参是变长数组

```cpp
void myFunction(int param[])
{
.
.
.
}
```


### 从函数返回数组

```cpp
int * myFunction()
{
.
.
.
}
```

## 指针

### 什么是指针

指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。

### 声明指针

```cpp
type *var-name;
```

### 使用指针

```cpp
int  var = 20;   // 实际变量的声明
int  *ip;        // 指针变量的声明
ip = &var;       // 在指针变量中存储 var 的地址
// 输出在指针变量中存储的地址
cout << ip << endl;
// 访问指针中地址的值
cout << *ip << endl;
```

### 指针详解

#### Null 指针

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。
NULL 指针是一个定义在标准库中的值为零的常量。

```cpp
#include <iostream>
using namespace std;
int main ()
{
   int  *ptr = NULL;
   cout << "ptr 的值是 " << ptr ;

   return 0;
}
```

### 指针的算术运算

指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。

#### 指针的比较

```cpp
#include <iostream>
using namespace std;
const int MAX = 3;
int main ()
{
   int  var[MAX] = {10, 100, 200};
   int  *ptr;
   // 指针中第一个元素的地址
   ptr = var;
   int i = 0;
   while ( ptr <= &var[MAX - 1] )
   {
      cout << "Address of var[" << i << "] = ";
      cout << ptr << endl;
      cout << "Value of var[" << i << "] = ";
      cout << *ptr << endl;
      // 指向上一个位置
      ptr++;
      i++;
   }
   return 0;
}
```

### 指针 vs 数组

```cpp
#include <iostream>

using namespace std;
const int MAX = 3;

int main ()
{
   int  var[MAX] = {10, 100, 200};

   for (int i = 0; i < MAX; i++)
   {
      *(var + i) = i;    // 这是正确的语法
   }
    int  *ptr;
	ptr = var;
   for (int i = 0; i < MAX; i++)
   {
      cout << "Address of var[" << i << "] = ";
      cout << ptr << endl;

      cout << "Value of var[" << i << "] = ";
      cout << *ptr << endl;

      // 移动到下一个位置
      ptr++;
   }
	return 0;
```

数组不能做左值，而指针可以。    例如做++操作。

```cpp
#include <iostream>
 
using namespace std;
const int MAX = 3;
 
int main ()
{
   int  var[MAX] = {10, 100, 200};
   int *ptr[MAX];
 
   for (int i = 0; i < MAX; i++)
   {
      ptr[i] = &var[i]; // 赋值为整数的地址
   }
   for (int i = 0; i < MAX; i++)
   {
      cout << "Value of var[" << i << "] = ";
      cout << *ptr[i] << endl;
   }
   return 0;
}
```
