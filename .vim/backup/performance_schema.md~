# MySQL Performance Schema

## Characteristics
1. The Performance Schema provides a way to inspect internal execution of the server at runtime.
2. The Performance Schema monitors server events(An “event” is anything the server does that takes time and has been instrumented so that timing information can be collected).
3. Performance Schema events are specific to a given instance of the MySQL Server. Performance Schema tables are considered local to the server, and changes to them are not replicated or written to the binary log.
4. Performance Schema configuration can be modified dynamically by updating tables in the performance_schema database through SQL statements. Configuration changes affect data collection immediately.
5. Tables in the performance_schema database are views or temporary tables that use no persistent on-disk storage.
6. As of MySQL 5.7.6, the Performance Schema allocates memory incrementally, scaling its memory use to actual server load, instead of allocating all the memory it needs during server startup.

## Performance Schema Quick Start
Tables in the performance_schema database can be grouped according to the type of information in them:
- Current events
- Event histories
- Summaries
- Object instances
- Setup (configuration) information

Initially, not all instruments and consumers are enabled, so the performance schema does not collect all events.  
To turn all of these on and enable event timing, execute two statements (the row counts may differ depending on MySQL version):

```sql
UPDATE setup_instruments SET ENABLED = 'YES', TIMED = 'YES';
UPDATE setup_consumers SET ENABLED = 'YES';
```

### Current indicates:
* The ID columns indicate which thread the event comes from and the event number.  
* EVENT_NAME indicates what was instrumented and SOURCE indicates which source file contains the instrumented code.  
* Timer values are approximate and expressed in picoseconds.

### History indicates:
The events_waits_history and events_waits_history_long tables contain the most recent 10 events per thread and most recent 10,000 events, respectively. For example, to see information for recent events produced by thread 13, do this:  
As new events are added to a history table, older events are discarded if the table is full.

### Summary indicates:
Summary tables provide aggregated information for all events over time. The tables in this group summarize event data in different ways.  
To see which instruments have been executed the most times or have taken the most wait time, sort the events_waits_summary_global_by_event_name table on the COUNT_STAR or SUM_TIMER_WAIT column, which correspond to a COUNT(*) or SUM(TIMER_WAIT) value, respectively, calculated over all events:
```sql
mysql> SELECT EVENT_NAME, COUNT_STAR
    -> FROM events_waits_summary_global_by_event_name
    -> ORDER BY COUNT_STAR DESC LIMIT 10;
+---------------------------------------------------+------------+
| EVENT_NAME                                        | COUNT_STAR |
+---------------------------------------------------+------------+
| wait/synch/mutex/mysys/THR_LOCK_malloc            |       6419 |
| wait/io/file/sql/FRM                              |        452 |
| wait/synch/mutex/sql/LOCK_plugin                  |        337 |
| wait/synch/mutex/mysys/THR_LOCK_open              |        187 |
| wait/synch/mutex/mysys/LOCK_alarm                 |        147 |
| wait/synch/mutex/sql/THD::LOCK_thd_data           |        115 |
| wait/io/file/myisam/kfile                         |        102 |
| wait/synch/mutex/sql/LOCK_global_system_variables |         89 |
| wait/synch/mutex/mysys/THR_LOCK::mutex            |         89 |
| wait/synch/mutex/sql/LOCK_open                    |         88 |
+---------------------------------------------------+------------+

mysql> SELECT EVENT_NAME, SUM_TIMER_WAIT
    -> FROM events_waits_summary_global_by_event_name
    -> ORDER BY SUM_TIMER_WAIT DESC LIMIT 10;
+----------------------------------------+----------------+
| EVENT_NAME                             | SUM_TIMER_WAIT |
+----------------------------------------+----------------+
| wait/io/file/sql/MYSQL_LOG             |     1599816582 |
| wait/synch/mutex/mysys/THR_LOCK_malloc |     1530083250 |
| wait/io/file/sql/binlog_index          |     1385291934 |
| wait/io/file/sql/FRM                   |     1292823243 |
| wait/io/file/myisam/kfile              |      411193611 |
| wait/io/file/myisam/dfile              |      322401645 |
| wait/synch/mutex/mysys/LOCK_alarm      |      145126935 |
| wait/io/file/sql/casetest              |      104324715 |
| wait/synch/mutex/sql/LOCK_plugin       |       86027823 |
| wait/io/file/sql/pid                   |       72591750 |
+----------------------------------------+----------------+
```

### Instance indicates:
These tables provide event names and explanatory notes or status information.
```sql
mysql> SELECT * FROM file_instances\G
*************************** 1. row ***************************
 FILE_NAME: /opt/mysql-log/60500/binlog.000007
EVENT_NAME: wait/io/file/sql/binlog
OPEN_COUNT: 0
*************************** 2. row ***************************
 FILE_NAME: /opt/mysql/60500/data/mysql/tables_priv.MYI
EVENT_NAME: wait/io/file/myisam/kfile
OPEN_COUNT: 1
*************************** 3. row ***************************
 FILE_NAME: /opt/mysql/60500/data/mysql/columns_priv.MYI
EVENT_NAME: wait/io/file/myisam/kfile
OPEN_COUNT: 1
...
```

### Setup indicates
Setup tables are used to configure and display monitoring characteristics.
#### set_timers
```sql
mysql> SELECT * FROM setup_timers;
+-------------+-------------+
| NAME        | TIMER_NAME  |
+-------------+-------------+
| idle        | MICROSECOND |
| wait        | CYCLE       |
| stage       | NANOSECOND  |
| statement   | NANOSECOND  |
| transaction | NANOSECOND  |
+-------------+-------------+
```
#### setup_instruments
setup_instruments lists the set of instruments for which events can be collected and shows which of them are enabled:
```sql
mysql> SELECT * FROM setup_instruments;
+------------------------------------------------------------+---------+-------+
| NAME                                                       | ENABLED | TIMED |
+------------------------------------------------------------+---------+-------+
...
| wait/synch/mutex/sql/LOCK_global_read_lock                 | YES     | YES   |
| wait/synch/mutex/sql/LOCK_global_system_variables          | YES     | YES   |
| wait/synch/mutex/sql/LOCK_lock_db                          | YES     | YES   |
| wait/synch/mutex/sql/LOCK_manager                          | YES     | YES   |
...
| wait/synch/rwlock/sql/LOCK_grant                           | YES     | YES   |
| wait/synch/rwlock/sql/LOGGER::LOCK_logger                  | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_connect                | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_slave                  | YES     | YES   |
...
| wait/io/file/sql/binlog                                    | YES     | YES   |
| wait/io/file/sql/binlog_index                              | YES     | YES   |
| wait/io/file/sql/casetest                                  | YES     | YES   |
| wait/io/file/sql/dbopt                                     | YES     | YES   |
...
```
To control whether events are collected for an instrument, set its ENABLED value to YES or NO. For example:
```sql
mysql> UPDATE setup_instruments SET ENABLED = 'NO'
    -> WHERE NAME = 'wait/synch/mutex/sql/LOCK_mysql_create_db';
```
#### setup_consumers
setup_consumers table lists the available consumers and which are enabled.
```sql
mysql> SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| events_stages_current            | NO      |
| events_stages_history            | NO      |
| events_stages_history_long       | NO      |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | NO      |
| events_transactions_current      | NO      |
| events_transactions_history      | NO      |
| events_transactions_history_long | NO      |
| events_waits_current             | NO      |
| events_waits_history             | NO      |
| events_waits_history_long        | NO      |
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| statements_digest                | YES     |
+----------------------------------+---------+
```
To control whether the Performance Schema maintains a consumer as a destination for event information, set its ENABLED value.
## Performance Schema Configuration
### Performance Schema Startup Configuration
To control an instrument at server startup, use an option of this form:  
```
--performance-schema-instrument='instrument_name=value'
```
Here, instrument_name is an instrument name such as wait/synch/mutex/sql/LOCK_open, and value is one of these values:
* OFF, FALSE, or 0: Disable the instrument
* ON, TRUE, or 1: Enable and time the instrument
* COUNTED: Enable and count (rather than time) the instrument

To configure all condition synchronization instruments as enabled and counted, use this option:
```
--performance-schema-instrument='wait/synch/cond/%=COUNTED'
```
To disable all instruments, use this option:
```
--performance-schema-instrument='%=OFF'
```
An unrecognized instrument name is ignored. It is possible that a plugin installed later may create the instrument, at which time the name is recognized and configured.  
To control a consumer at server startup, use an option of this form:
```
--performance-schema-consumer-consumer_name=value
```
Here, consumer_name is a consumer name such as events_waits_history, and value is one of these values:
* OFF, FALSE, or 0: Do not collect events for the consumer
* ON, TRUE, or 1: Collect events for the consumer

The Performance Schema includes several system variables that provide configuration information:
```sql
mysql> SHOW VARIABLES LIKE 'perf%';
+--------------------------------------------------------+---------+
| Variable_name                                          | Value   |
+--------------------------------------------------------+---------+
| performance_schema                                     | ON      |
| performance_schema_accounts_size                       | 100     |
| performance_schema_digests_size                        | 200     |
| performance_schema_events_stages_history_long_size     | 10000   |
| performance_schema_events_stages_history_size          | 10      |
| performance_schema_events_statements_history_long_size | 10000   |
| performance_schema_events_statements_history_size      | 10      |
| performance_schema_events_waits_history_long_size      | 10000   |
| performance_schema_events_waits_history_size           | 10      |
| performance_schema_hosts_size                          | 100     |
| performance_schema_max_cond_classes                    | 80      |
| performance_schema_max_cond_instances                  | 1000    |
...
```
The performance_schema variable is ON or OFF to indicate whether the Performance Schema is enabled or disabled.  
The other variables indicate table sizes (number of rows) or memory allocation values.
To change the value of Performance Schema system variables, set them at server startup. For example, put the following lines in a my.cnf file to change the sizes of the history tables for wait events:
```
[mysqld]
performance_schema
performance_schema_events_waits_history_size=20
performance_schema_events_waits_history_long_size=15000
```
To see which parameters are autosized or autoscaled, use mysqld --verbose --help and examine the option descriptions.

For each autosized parameter that is not set at server startup (or is set to −1), the Performance Schema determines how to set its value based on the value of the following system values, which are considered as “hints” about how you have configured your MySQL server:
```
max_connections
open_files_limit
table_definition_cache
table_open_cache
```
To override autosizing or autoscaling for a given parameter, set it to a value other than −1 at startup. In this case, the Performance Schema assigns it the specified value.  
t runtime, SHOW VARIABLES displays the actual values that autosized parameters were set to. Autoscaled parameters display with a value of −1.  
If the Performance Schema is disabled, its autosized and autoscaled parameters remain set to −1 and SHOW VARIABLES displays −1.
### Performance Schema Runtime Configuration
Performance Schema setup tables contain information about monitoring configuration:
```sql
mysql> SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
    -> WHERE TABLE_SCHEMA = 'performance_schema'
    -> AND TABLE_NAME LIKE 'setup%';
+-------------------+
| TABLE_NAME        |
+-------------------+
| setup_actors      |
| setup_consumers   |
| setup_instruments |
| setup_objects     |
| setup_timers      |
+-------------------+
```
#### Performance Schema Event Timing

**Performance Schema Timers**
Two Performance Schema tables provide timer information:
* performance_timers lists the available timers and their characteristics.
* setup_timers indicates which timers are used for which instruments.
Each timer row in setup_timers must refer to one of the timers listed in performance_timers.  
Timers vary in precision and amount of overhead. To see what timers are available and their characteristics, check the performance_timers table:
```sql
mysql> SELECT * FROM performance_timers;
+-------------+-----------------+------------------+----------------+
| TIMER_NAME  | TIMER_FREQUENCY | TIMER_RESOLUTION | TIMER_OVERHEAD |
+-------------+-----------------+------------------+----------------+
| CYCLE       |      2389029850 |                1 |             72 |
| NANOSECOND  |      1000000000 |                1 |            112 |
| MICROSECOND |         1000000 |                1 |            136 |
| MILLISECOND |            1036 |                1 |            168 |
| TICK        |             105 |                1 |           2416 |
+-------------+-----------------+------------------+----------------+
```
The columns have these meanings:

* The TIMER_NAME column shows the names of the available timers. CYCLE refers to the timer that is based on the CPU (processor) cycle counter. The timers in setup_timers that you can use are those that do not have NULL in the other columns. If the values associated with a given timer name are NULL, that timer is not supported on your platform.
* TIMER_FREQUENCY indicates the number of timer units per second. For a cycle timer, the frequency is generally related to the CPU speed. The value shown was obtained on a system with a 2.4GHz processor. The other timers are based on fixed fractions of seconds. For TICK, the frequency may vary by platform (for example, some use 100 ticks/second, others 1000 ticks/second).
* TIMER_RESOLUTION indicates the number of timer units by which timer values increase at a time. If a timer has a resolution of 10, its value increases by 10 each time.
* TIMER_OVERHEAD is the minimal number of cycles of overhead to obtain one timing with the given timer. The overhead per event is twice the value displayed because the timer is invoked at the beginning and end of the event.

To time wait events, the most important criterion is to reduce overhead, at the possible expense of the timer accuracy, so using the CYCLE timer is the best.  
To time statements, the most important criterion is to have an accurate measure, which is not affected by changes in processor frequency, so using a timer which is not based on cycles is the best. The default timer for statements is NANOSECOND. The extra “overhead” compared to the CYCLE timer is not significant, because the overhead caused by calling a timer twice (once when the statement starts, once when it ends) is orders of magnitude less compared to the CPU time used to execute the statement itself. Using the CYCLE timer has no benefit here, only drawbacks.

Cycle counters also have disadvantages:
* End users expect to see timings in wall-clock units, such as fractions of a second. Converting from cycles to fractions of seconds can be expensive. For this reason, the conversion is a quick and fairly rough multiplication operation.
* Processor cycle rate might change. If a processor's cycle rate fluctuates, conversion from cycles to real-time units is subject to error.
* Cycle counters might be unreliable or unavailable depending on the processor or the operating system.
* Some processor details related to out-of-order execution or multiprocessor synchronization might cause the counter to seem fast or slow by up to 1000 cycles.

**Performance Schema Timer Representation in Events**
Rows in Performance Schema tables that store current events and historical events have three columns to represent timing information: TIMER_START and TIMER_END indicate when an event started and finished, and TIMER_WAIT indicates event duration.

The **setup_instruments** table has an ENABLED column to indicate the instruments for which to collect events. The table also has a TIMED column to indicate which instruments are timed.  
If an instrument is not enabled, it produces no events.  
If an enabled instrument is not timed, events produced by the instrument have NULL for the TIMER_START, TIMER_END, and TIMER_WAIT timer values. This in turn causes those values to be ignored when calculating the sum, minimum, maximum, and average time values in summary tables.

Modifications to the setup_timers table affect monitoring immediately. Events already in progress may use the original timer for the begin time and the new timer for the end time.  
To avoid unpredictable results after you make timer changes, use TRUNCATE TABLE to reset Performance Schema statistics.

The timer baseline (“time zero”) occurs at Performance Schema initialization during server startup. TIMER_START and TIMER_END values in events represent picoseconds since the baseline. TIMER_WAIT values are durations in picoseconds.

The choice of picoseconds in events rather than a value such as microseconds has a performance basis. This precision is spurious, but the decision enables overhead to be minimized.

Before MySQL 5.7.8, while a wait, stage, statement, or transaction event is executing, the respective current-event tables display the event with **TIMER_START** populated, but with **TIMER_END** and **TIMER_WAIT** set to NULL:
```
events_waits_current
events_stages_current
events_statements_current
events_transactions_current
```

As of MySQL 5.7.8, current-event timing provides more information. To make it possible to determine how how long a not-yet-completed event has been running, the timer columns are set as follows:
* **TIMER_START** is populated (unchanged from previous behavior)
* **TIMER_END** is populated with the current timer value
* **TIMER_WAIT** is populated with the time elapsed so far (TIMER_END − TIMER_START)

Events that have not yet completed have an END_EVENT_ID value of NULL. To assess time elapsed so far for an event, use the TIMER_WAIT column. Therefore, to identify events that have not yet completed and have taken longer than N picoseconds thus far, monitoring applications can use this expression in queries:
```sql
WHERE END_EVENT_ID IS NULL AND TIMER_WAIT > N
```

#### Performance Schema Event Filtering
Events are processed in a producer/consumer fashion:
* Instrumented code is the source for events and produces events to be collected. The setup_instruments table lists the instruments for which events can be collected, whether they are enabled, and (for enabled instruments) whether to collect timing information:
```sql
mysql> SELECT * FROM setup_instruments;
+------------------------------------------------------------+---------+-------+
| NAME                                                       | ENABLED | TIMED |
+------------------------------------------------------------+---------+-------+
...
| wait/synch/mutex/sql/LOCK_global_read_lock                 | YES     | YES   |
| wait/synch/mutex/sql/LOCK_global_system_variables          | YES     | YES   |
| wait/synch/mutex/sql/LOCK_lock_db                          | YES     | YES   |
| wait/synch/mutex/sql/LOCK_manager                          | YES     | YES   |
...
```
* Performance Schema tables are the destinations for events and consume events. The setup_consumers table lists the types of consumers to which event information can be sent and whether they are enabled:
```sql
mysql> SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| events_stages_current            | NO      |
| events_stages_history            | NO      |
| events_stages_history_long       | NO      |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | NO      |
| events_transactions_current      | NO      |
| events_transactions_history      | NO      |
| events_transactions_history_long | NO      |
| events_waits_current             | NO      |
| events_waits_history             | NO      |
| events_waits_history_long        | NO      |
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| statements_digest                | YES     |
+----------------------------------+---------+
```

Filtering can be done at different stages of performance monitoring:
* **Pre-filtering**. This is done by modifying Performance Schema configuration so that only certain types of events are collected from producers, and collected events update only certain consumers. To do this, enable or disable instruments or consumers. Pre-filtering is done by the Performance Schema and has a global effect that applies to all users.  
Reasons to use pre-filtering:
* To reduce overhead.
* To avoid filling the current-events or history tables with events in which you have no interest.
* To avoid maintaining some kinds of event tables. If you disable a consumer, the server does not spend time maintaining destinations for that consumer.

* **Post-filtering**. This involves the use of WHERE clauses in queries that select information from Performance Schema tables, to specify which of the available events you want to see. Post-filtering is performed on a per-user basis because individual users select which of the available events are of interest.  
Reasons to use post-filtering:
* To avoid making decisions for individual users about which event information is of interest.
* To use the Performance Schema to investigate a performance issue when the restrictions to impose using pre-filtering are not known in advance.

#### Event Pre-Filtering
Pre-filtering is done by the Performance Schema and has a global effect that applies to all users. Pre-filtering can be applied to either the producer or consumer stage of event processing:
* To configure pre-filtering at the producer stage, several tables can be used:
  - **setup_instruments** indicates which instruments are available. An instrument disabled in this table produces no events regardless of the contents of the other production-related setup tables. An instrument enabled in this table is permitted to produce events, subject to the contents of the other tables.
  - **setup_objects** controls whether the Performance Schema monitors particular table and stored program objects.
  - **threads** indicates whether monitoring is enabled for each server thread.
  - **setup_actors** determines the initial monitoring state for new foreground threads.
* To configure pre-filtering at the consumer stage, modify the setup_consumers table. This determines the destinations to which events are sent. setup_consumers also implicitly affects event production. **If a given event will not be sent to any destination (that is, will not be consumed)**,  **the Performance Schema does not produce it**.

Modifications to any of these tables affect monitoring immediately, with some exceptions:
* Modifications to some instruments in the setup_instruments table are effective only at server startup; changing them at runtime has no effect. This affects primarily mutexes, conditions, and rwlocks in the server, although there may be other instruments for which this is true. This restriction is lifted as of MySQL 5.7.12.
* Modifications to the setup_actors table affect only foreground threads created subsequent to the modification, not existing threads.

When you change the monitoring configuration, the Performance Schema does not flush the history tables. Events already collected remain in the current-events and history tables until displaced by newer events.  
If you disable instruments, you might need to wait a while before events for them are displaced by newer events of interest. Alternatively, use TRUNCATE TABLE to empty the history table.  
Except for events_statements_summary_by_digest and the memory summary tables, the effect of TRUNCATE TABLE for summary tables is to reset the summary columns to 0 or NULL, not to remove rows.

##### Pre-Filtering by Instrument
The setup_instruments table lists the available instruments:
```sql
mysql> SELECT * FROM setup_instruments;
+------------------------------------------------------------+---------+-------+
| NAME                                                       | ENABLED | TIMED |
+------------------------------------------------------------+---------+-------+
...
| wait/synch/mutex/sql/LOCK_global_read_lock                 | YES     | YES   |
| wait/synch/mutex/sql/LOCK_global_system_variables          | YES     | YES   |
| wait/synch/mutex/sql/LOCK_lock_db                          | YES     | YES   |
| wait/synch/mutex/sql/LOCK_manager                          | YES     | YES   |
...
| wait/synch/rwlock/sql/LOCK_grant                           | YES     | YES   |
| wait/synch/rwlock/sql/LOGGER::LOCK_logger                  | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_connect                | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_slave                  | YES     | YES   |
...
| wait/io/file/sql/binlog                                    | YES     | YES   |
| wait/io/file/sql/binlog_index                              | YES     | YES   |
| wait/io/file/sql/casetest                                  | YES     | YES   |
| wait/io/file/sql/dbopt                                     | YES     | YES   |
...
```
Modifications to most **setup_instruments** rows affect monitoring immediately. For some instruments, modifications are effective only at server startup; changing them at runtime has no effect.  
This affects primarily mutexes, conditions, and rwlocks in the server, although there may be other instruments for which this is true.

```sql
Disable all instruments:

mysql> UPDATE setup_instruments SET ENABLED = 'NO';
Now no events will be collected.

Disable all file instruments, adding them to the current set of disabled instruments:

mysql> UPDATE setup_instruments SET ENABLED = 'NO'
    -> WHERE NAME LIKE 'wait/io/file/%';
Disable only file instruments, enable all other instruments:

mysql> UPDATE setup_instruments
    -> SET ENABLED = IF(NAME LIKE 'wait/io/file/%', 'NO', 'YES');
Enable all but those instruments in the mysys library:

mysql> UPDATE setup_instruments
    -> SET ENABLED = CASE WHEN NAME LIKE '%/mysys/%' THEN 'YES' ELSE 'NO' END;
Disable a specific instrument:

mysql> UPDATE setup_instruments SET ENABLED = 'NO'
    -> WHERE NAME = 'wait/synch/mutex/mysys/TMPDIR_mutex';
To toggle the state of an instrument, “flip” its ENABLED value:

mysql> UPDATE setup_instruments
    -> SET ENABLED = IF(ENABLED = 'YES', 'NO', 'YES')
    -> WHERE NAME = 'wait/synch/mutex/mysys/TMPDIR_mutex';
Disable timing for all events:

mysql> UPDATE setup_instruments SET TIMED = 'NO';
```

##### Pre-Filtering by Object
The setup_objects table controls whether the Performance Schema monitors particular table and stored program objects. The initial setup_objects contents look like this:
```sql
mysql> SELECT * FROM setup_objects;
+-------------+--------------------+-------------+---------+-------+
| OBJECT_TYPE | OBJECT_SCHEMA      | OBJECT_NAME | ENABLED | TIMED |
+-------------+--------------------+-------------+---------+-------+
| EVENT       | mysql              | %           | NO      | NO    |
| EVENT       | performance_schema | %           | NO      | NO    |
| EVENT       | information_schema | %           | NO      | NO    |
| EVENT       | %                  | %           | YES     | YES   |
| FUNCTION    | mysql              | %           | NO      | NO    |
| FUNCTION    | performance_schema | %           | NO      | NO    |
| FUNCTION    | information_schema | %           | NO      | NO    |
| FUNCTION    | %                  | %           | YES     | YES   |
| PROCEDURE   | mysql              | %           | NO      | NO    |
| PROCEDURE   | performance_schema | %           | NO      | NO    |
| PROCEDURE   | information_schema | %           | NO      | NO    |
| PROCEDURE   | %                  | %           | YES     | YES   |
| TABLE       | mysql              | %           | NO      | NO    |
| TABLE       | performance_schema | %           | NO      | NO    |
| TABLE       | information_schema | %           | NO      | NO    |
| TABLE       | %                  | %           | YES     | YES   |
| TRIGGER     | mysql              | %           | NO      | NO    |
| TRIGGER     | performance_schema | %           | NO      | NO    |
| TRIGGER     | information_schema | %           | NO      | NO    |
| TRIGGER     | %                  | %           | YES     | YES   |
+-------------+--------------------+-------------+---------+-------+
```
Modifications to the setup_objects table affect object monitoring immediately.

The **OBJECT_TYPE**  column indicates the type of object to which a row applies. TABLE filtering affects table I/O events (wait/io/table/sql/handler instrument) and table lock events (wait/lock/table/sql/handler instrument).  
The OBJECT_SCHEMA and OBJECT_NAME columns should contain a literal schema or object name, or '%' to match any name.  
The ENABLED column indicates whether matching objects are monitored, and TIMED indicates whether to collect timing information.

When the Performance Schema checks for a match in setup_objects, it tries to find more specific matches first. For rows that match a given OBJECT_TYPE, the Performance Schema checks rows in this order:
* Rows with OBJECT_SCHEMA='literal' and OBJECT_NAME='literal'.
* Rows with OBJECT_SCHEMA='literal' and OBJECT_NAME='%'.
* Rows with OBJECT_SCHEMA='%'       and OBJECT_NAME='%'.

For table-related events, the Performance Schema combines the contents of setup_objects with setup_instruments to determine whether to enable instruments and whether to time enabled instruments:
* For tables that match a row in setup_objects, table instruments produce events only if ENABLED is YES in both setup_instruments and setup_objects.
* The TIMED values in the two tables are combined, so that timing information is collected only when both values are YES.

##### Pre-Filtering by Thread

The threads table contains a row for each server thread. Each row contains information about a thread and indicates whether monitoring is enabled for it. For the Performance Schema to monitor a thread, these things must be true:
* The thread_instrumentation consumer in the setup_consumers table must be YES.
* The threads.INSTRUMENTED column must be YES.
* Monitoring occurs only for those thread events produced from instruments that are enabled in the setup_instruments table.

```sql
select thread_id , name ,type ,instrumented, history from threads;
+-----------+----------------------------------------+------------+--------------+---------+
| thread_id | name                                   | type       | instrumented | history |
+-----------+----------------------------------------+------------+--------------+---------+
|         1 | thread/sql/main                        | BACKGROUND | YES          | YES     |
|         2 | thread/sql/thread_timer_notifier       | BACKGROUND | YES          | YES     |
|         3 | thread/innodb/io_ibuf_thread           | BACKGROUND | YES          | YES     |
|         4 | thread/innodb/io_log_thread            | BACKGROUND | YES          | YES     |
|         5 | thread/innodb/io_read_thread           | BACKGROUND | YES          | YES     |
|         6 | thread/innodb/io_read_thread           | BACKGROUND | YES          | YES     |
|         7 | thread/innodb/io_read_thread           | BACKGROUND | YES          | YES     |
|         8 | thread/innodb/io_read_thread           | BACKGROUND | YES          | YES     |
|         9 | thread/innodb/io_write_thread          | BACKGROUND | YES          | YES     |
...
|        26 | thread/sql/compress_gtid_table         | FOREGROUND | YES          | YES     |
...
```

The threads table also indicates for each server thread whether to perform historical event logging. This includes wait, stage, statement, and transaction events and affects logging to these tables:
```
events_waits_history
events_waits_history_long
events_stages_history
events_stages_history_long
events_statements_history
events_statements_history_long
events_transactions_history
events_transactions_history_long
```
For historical event logging to occur, these things must be true:
* The appropriate history-related consumers in the setup_consumers table must be enabled. For example, wait event logging in the events_waits_history and events_waits_history_long tables requires the corresponding events_waits_history and events_waits_history_long consumers to be YES.
* The threads.HISTORY column must be YES.
* Logging occurs only for those thread events produced from instruments that are enabled in the setup_instruments table.

##### Pre-Filtering by actors
For **foreground threads** (resulting from client connections), the initial values of the INSTRUMENTED and HISTORY columns in threads table rows are determined by whether the **user account associated with a thread matches any row in the setup_actors table**. The values come from the ENABLED and HISTORY columns of the matching setup_actors table row.

For **background threads,** there is no associated user. INSTRUMENTED and HISTORY are YES by default and setup_actors is not consulted.  
The initial setup_actors contents look like this:
```sql
mysql> SELECT * FROM setup_actors;
+------+------+------+---------+---------+
| HOST | USER | ROLE | ENABLED | HISTORY |
+------+------+------+---------+---------+
| %    | %    | %    | YES     | YES     |
+------+------+------+---------+---------+
```
The HOST and USER columns should contain a literal host or user name, or '%' to match any name.  
The ENABLED and HISTORY columns indicate whether to enable instrumentation and historical event logging for matching threads, subject to the other conditions described previously.  

Suppose that you modify setup_actors as follows:
```sql
UPDATE setup_actors SET ENABLED = 'NO', HISTORY = 'NO'
WHERE HOST = '%' AND USER = '%';
INSERT INTO setup_actors (HOST,USER,ROLE,ENABLED,HISTORY)
    VALUES('localhost','joe','%','YES','YES');
INSERT INTO setup_actors (HOST,USER,ROLE,ENABLED,HISTORY)
    VALUES('hosta.example.com','joe','%','YES','NO');
INSERT INTO setup_actors (HOST,USER,ROLE,ENABLED,HISTORY)
    VALUES('%','sam','%','NO','YES');
```
Modifications to the setup_actors table affect only foreground threads created subsequent to the modification, not existing threads.  
To affect existing threads, modify the INSTRUMENTED and HISTORY columns of threads table rows.

##### Pre-Filtering by Consumer
The setup_consumers table lists the available consumer types and which are enabled:
```sql
mysql> SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| events_stages_current            | NO      |
| events_stages_history            | NO      |
| events_stages_history_long       | NO      |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | NO      |
| events_transactions_current      | NO      |
| events_transactions_history      | NO      |
| events_transactions_history_long | NO      |
| events_waits_current             | NO      |
| events_waits_history             | NO      |
| events_waits_history_long        | NO      |
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| statements_digest                | YES     |
+----------------------------------+---------+
```
Modify the setup_consumers table to affect pre-filtering at the consumer stage and determine the destinations to which events are sent. To enable or disable a consumer, set its ENABLED value to YES or NO.  
Modifications to the setup_consumers table affect monitoring immediately.  
If you disable a consumer, the server does not spend time maintaining destinations for that consumer. For example, if you do not care about historical event information, disable the history consumers:
```sql
mysql> UPDATE setup_consumers
    -> SET ENABLED = 'NO' WHERE NAME LIKE '%history%';
```

The consumer settings in the setup_consumers table form a hierarchy from higher levels to lower. The following principles apply:
* Destinations associated with a consumer receive no events unless the Performance Schema checks the consumer and the consumer is enabled.
* A consumer is checked only if all consumers it depends on (if any) are enabled.
* If a consumer is not checked, or is checked but is disabled, other consumers that depend on it are not checked.
* Dependent consumers may have their own dependent consumers.
* If an event would not be sent to any destination, the Performance Schema does not produce it.

**Global and Thread Consumers**
* **global_instrumentation** is the highest level consumer. If global_instrumentation is NO, it disables global instrumentation. All other settings are lower level and are not checked; it does not matter what they are set to. No global or per thread information is maintained and no individual events are collected in the current-events or event-history tables. If global_instrumentation is YES, the Performance Schema maintains information for global states and also checks the thread_instrumentation consumer.
* **thread_instrumentation** is checked only if global_instrumentation is YES. Otherwise, if thread_instrumentation is NO, it disables thread-specific instrumentation and all lower-level settings are ignored. No information is maintained per thread and no individual events are collected in the current-events or event-history tables. If thread_instrumentation is YES, the Performance Schema maintains thread-specific information and also checks events_xxx_current consumers.

**Wait/Stage/Statement/Transaction Event Consumers**  
These consumers require both global_instrumentation and thread_instrumentation to be YES or they are not checked. If checked, they act as follows:
* events_xxx_current, if NO, disables collection of individual wait events in the events_xxx_current table. If YES, it enables wait event collection and the Performance Schema checks the events_xxx_history and events_xxx_history_long consumers.
* events_xxx_history is not checked if event_xxx_current is NO. Otherwise, an events_xxx_history value of NO or YES disables or enables collection of wait events in the events_xxx_history table.
* events_xxx_history_long is not checked if event_xxx_current is NO. Otherwise, an events_xxx_history_long value of NO or YES disables or enables collection of wait events in the events_xxx_history_long table.

**tatement Digest Consumer**  
This consumer requires global_instrumentation to be YES or it is not checked.  
There is no dependency on the statement event consumers, so you can obtain statistics per digest without having to collect statistics in events_statements_current, which is advantageous in terms of overhead. Conversely, you can get detailed statements in events_statements_current without digests (the DIGEST and DIGEST_TEXT columns will be NULL).

![setup_relation](performance_schema_setup.bmp)

consumer's hierarchy from higher levels to lower:
```
global_instrumentation
 thread_instrumentation
   events_waits_current
     events_waits_history
     events_waits_history_long
   events_stages_current
     events_stages_history
     events_stages_history_long
   events_statements_current
     events_statements_history
     events_statements_history_long
   events_transactions_current
     events_transactions_history
     events_transactions_history_long
 statements_digest
 ```

##### Example Consumer Configurations

###### No Instrumentation
```sql
mysql> SELECT * FROM setup_consumers;
+---------------------------+---------+
| NAME                      | ENABLED |
+---------------------------+---------+
| global_instrumentation    | NO      |
...
+---------------------------+---------+
```
Nothing is instrumented.

|Item|Info|
|---|---|
|Setup elements checked|Table setup_consumersi, consumer global_instrumentation|
|Output tables maintained|None|

###### Global Instrumentation Only
```
mysql> SELECT * FROM setup_consumers;
+---------------------------+---------+
| NAME                      | ENABLED |
+---------------------------+---------+
| global_instrumentation    | YES     |
| thread_instrumentation    | NO      |
...
+---------------------------+---------+
```
Instrumentation is maintained only for global states. Per-thread instrumentation is disabled.

|Item|Info|
|---|---|
|setup elements checked|Table setup_consumers, consumer thread_instrumentation<br />Table setup_instruments<br />Table setup_objects<br />Table setup_timers|
|Output tables maintained|mutex_instances<br \>rwlock_instances<br \>cond_instances<br \>file_instances<br \>users<br \>hosts<br \>accounts<br \>socket_summary_by_event_name<br \>file_summary_by_instance<br \>file_summary_by_event_name<br \>objects_summary_global_by_type<br \>memory_summary_global_by_event_name<br \>table_lock_waits_summary_by_table<br \>table_io_waits_summary_by_index_usage<br \>table_io_waits_summary_by_table<br \>events_waits_summary_by_instance<br \>events_waits_summary_global_by_event_name<br \>events_stages_summary_global_by_event_name<br \>events_statements_summary_global_by_event_name<br \>events_transactions_summary_global_by_event_name<br \>|

###### Global and Thread Instrumentation Only
```sql`
mysql> SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| events_waits_current             | NO      |
...
| events_stages_current            | NO      |
...
| events_statements_current        | NO      |
...
| events_transactions_current      | NO      |
...
+----------------------------------+---------+
```
Instrumentation is maintained globally and per thread. No individual events are collected in the current-events or event-history tables.  

|Item|Info|
|---|---|
|**Additional** setup elements checked|Table setup_consumers, consumers events_xxx_current, where xxx is waits, stages, statements, transactions<br \>Table setup_actor<br \>Column threads.instrumented|
|**Additional** output tables maintained|events_xxx_summary_by_yyy_by_event_name, where xxx is waits, stages, statements, transactions; and yyy is thread, user, host, account|

###### Global, Thread, and Current-Event Instrumentation
```sql
mysql> SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| events_waits_current             | YES     |
| events_waits_history             | NO      |
| events_waits_history_long        | NO      |
| events_stages_current            | YES     |
| events_stages_history            | NO      |
| events_stages_history_long       | NO      |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | NO      |
| events_transactions_current      | YES     |
| events_transactions_history      | YES     |
| events_transactions_history_long | NO      |
...
+----------------------------------+---------+
```
Instrumentation is maintained globally and per thread. Individual events are collected in the current-events table, but not in the event-history tables.

|Item|Info|
|---|---|
|Additional setup elements checked|Consumers events_xxx_history, where xxx is waits, stages, statements, transactions<br \>Consumers events_xxx_history_long, where xxx is waits, stages, statements, transactions|
|Additional output tables maintained|events_xxx_current, where xxx is waits, stages, statements, transactions|

###### Global, Thread, Current-Event, and Event-History instrumentation

```sql
mysql> SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| events_waits_current             | YES     |
| events_waits_history             | YES     |
| events_waits_history_long        | NO      |
| events_stages_current            | YES     |
| events_stages_history            | YES     |
| events_stages_history_long       | NO      |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | NO      |
| events_transactions_current      | YES     |
| events_transactions_history      | YES     |
| events_transactions_history_long | NO      |
...
+----------------------------------+---------+
```
Event-history tables maintained for this configuration:  
events_xxx_history, where xxx is waits, stages, statements, transactions

```sql
mysql> SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| events_waits_current             | YES     |
| events_waits_history             | YES     |
| events_waits_history_long        | YES     |
| events_stages_current            | YES     |
| events_stages_history            | NO      |
| events_stages_history_long       | YES     |
| events_statements_current        | YES     |
| events_statements_history        | NO      |
| events_statements_history_long   | YES     |
| events_transactions_current      | YES     |
| events_transactions_history      | NO      |
| events_transactions_history_long | YES     |
...
+----------------------------------+---------+
```
events_xxx_history_long, where xxx is waits, stages, statements, transactions

## Performance Schema Instrument Naming Conventions

The **suffix** part of instrument names comes from the code for the instruments themselves. Suffixes may include levels such as these:
* A name for the major component (a server module such as myisam, innodb, mysys, or sql) or a plugin name.
* The name of a variable in the code, in the form XXX (a global variable) or CCC::MMM (a member MMM in class CCC). Examples: COND_thread_cache, THR_LOCK_myisam, BINLOG::LOCK_index.

Top-Level Instrument Components
* idle: An instrumented idle event. This instrument has no further components.
* memory: An instrumented memory event.
* stage: An instrumented stage event.
* statement: An instrumented statement event.
* transaction: An instrumented transaction event. This instrument has no further components.
* wait: An instrumented wait event.

**Idle Instrument Components**

* idle  
The idle instrument. The Performance Schema generates idle events as discussed in the description of the socket_instances.

**Memory Instrument Components**

Most memory instrumentation is disabled by default, and can be enabled or disabled dynamically by updating the ENABLED column of the relevant instruments in the setup_instruments table. Memory instruments have names of the form memory/code_area/instrument_name where code_area is a value such as sql or myisam, and instrument_name is the instrument detail.

**Stage Instrument Components**

Stage instruments have names of the form stage/code_area/stage_name, where code_area is a value such as sql or myisam, and stage_name indicates the stage of statement processing, such as Sorting result or Sending data. Stages correspond to the thread states displayed by SHOW PROCESSLIST or that are visible in the INFORMATION_SCHEMA.PROCESSLIST table.

**Statement Instrument Components**

|Component|Info|
|:---|:---|
|statement/abstract/*| An abstract instrument for statement operations. Abstract instruments are used during the **early stages** of statement classification before the exact statement type is known, then changed to a more specific statement instrument when the type is known.|
|statement/com| An instrumented command operation. These have names corresponding to COM_xxx operations.|
|statement/scheduler/event| A single instrument to track all events executed by the Event Scheduler. This instrument comes into play when a scheduled event begins executing.|
|statement/sp| An instrumented internal instruction executed by a stored program.|
|statement/sql| An instrumented SQL statement operation.|

**Wait Instrument Components**

* wait/io  
An instrumented I/O operation.

|Component|Info|
|:---|:---|
|wait/io/file|An instrumented file I/O operation. For files, the wait is the time waiting for the file operation to complete (for example, a call to fwrite()). Due to caching, the physical file I/O on the disk might not happen within this call.|
|wait/io/socket|An instrumented socket operation. Socket instruments have names of the form wait/io/socket/sql/socket_type. The server has a listening socket for each network protocol that it supports. The instruments associated with listening sockets for TCP/IP or Unix socket file connections have a socket_type value of server_tcpip_socket or server_unix_socket, respectively. When a listening socket detects a connection, the server transfers the connection to a new socket managed by a separate thread. The instrument for the new connection thread has a socket_type value of client_connection.|
|wait/io/table|An instrumented table I/O operation. These include row-level accesses to persistent base tables or temporary tables. Operations that affect rows are fetch, insert, update, and delete. For a view, waits are associated with base tables referenced by the view.<br \>Unlike most waits, a table I/O wait can include other waits. For example, table I/O might include file I/O or memory operations. Thus, events_waits_current for a table I/O wait usually has two rows.<br \>Some row operations might cause multiple table I/O waits. For example, an insert might activate a trigger that causes an update.|


* wait/lock  
An instrumented lock operation.

|Component|Info|
|:---|:---|
|wait/lock/table|An instrumented table lock operation.|
|wait/lock/metadata/sql/mdl|An instrumented metadata lock operation (disabled by default).|

* wait/synch  
An instrumented synchronization object. For synchronization objects, the TIMER_WAIT time includes the amount of time blocked while attempting to acquire a lock on the object, if any.

|Component|Info|
|:---|:---|
|wait/synch/cond|A condition is used by one thread to signal to other threads that something they were waiting for has happened. If a single thread was waiting for a condition, it can wake up and proceed with its execution. If several threads were waiting, they can all wake up and compete for the resource for which they were waiting.|
|wait/synch/mutex|A mutual exclusion object used to permit access to a resource (such as a section of executable code) while preventing other threads from accessing the resource.|
|wait/synch/rwlock|A read/write lock object used to lock a specific variable for access while preventing its use by other threads. A shared read lock can be acquired simultaneously by multiple threads. An exclusive write lock can be acquired by only one thread at a time.|
|wait/synch/sxlock|A shared-exclusive (SX) lock is a type of rwlock lock object that provides write access to a common resource while permitting inconsistent reads by other threads. sxlocks were introduced in MySQL 5.7 to optimize concurrency and improve scalability for read-write workloads.|

## Performance Schema Status Monitoring

There are several status variables associated with the Performance Schema:  
```sql
mysql> SHOW STATUS LIKE 'perf%';
+-----------------------------------------------+-------+
| Variable_name                                 | Value |
+-----------------------------------------------+-------+
| Performance_schema_accounts_lost              | 0     |
| Performance_schema_cond_classes_lost          | 0     |
| Performance_schema_cond_instances_lost        | 0     |
| Performance_schema_digest_lost                | 0     |
| Performance_schema_file_classes_lost          | 0     |
| Performance_schema_file_handles_lost          | 0     |
| Performance_schema_file_instances_lost        | 0     |
| Performance_schema_hosts_lost                 | 0     |
| Performance_schema_locker_lost                | 0     |
| Performance_schema_memory_classes_lost        | 0     |
| Performance_schema_metadata_lock_lost         | 0     |
| Performance_schema_mutex_classes_lost         | 0     |
| Performance_schema_mutex_instances_lost       | 0     |
| Performance_schema_nested_statement_lost      | 0     |
| Performance_schema_program_lost               | 0     |
| Performance_schema_rwlock_classes_lost        | 0     |
| Performance_schema_rwlock_instances_lost      | 0     |
| Performance_schema_session_connect_attrs_lost | 0     |
| Performance_schema_socket_classes_lost        | 0     |
| Performance_schema_socket_instances_lost      | 0     |
| Performance_schema_stage_classes_lost         | 0     |
| Performance_schema_statement_classes_lost     | 0     |
| Performance_schema_table_handles_lost         | 0     |
| Performance_schema_table_instances_lost       | 0     |
| Performance_schema_thread_classes_lost        | 0     |
| Performance_schema_thread_instances_lost      | 0     |
| Performance_schema_users_lost                 | 0     |
+-----------------------------------------------+-------+
```
The Performance Schema status variables provide information about instrumentation that could not be loaded or created due to memory constraints. Names for these variables have several forms:
* Performance_schema_xxx_classes_lost indicates how many instruments of type xxx could not be loaded.
* Performance_schema_xxx_instances_lost indicates how many instances of object type xxx could not be created.
* Performance_schema_xxx_handles_lost indicates how many instances of object type xxx could not be opened.
* Performance_schema_locker_lost indicates how many events are “lost” or not recorded.

Suppose that the following conditions hold:
* The server was started with the --performance_schema_max_mutex_classes=200 option and thus has room for 200 mutex instruments.
* 150 mutex instruments have been loaded already.
* The plugin named plugin_a contains 40 mutex instruments.
* The plugin named plugin_b contains 20 mutex instruments.

The server allocates mutex instruments for the plugins depending on how many they need and how many are available, as illustrated by the following sequence of statements:

```
INSTALL PLUGIN plugin_a
```

The server now has 150+40 = 190 mutex instruments.

```
UNINSTALL PLUGIN plugin_a;
```

The server **still has 190 instruments**. All the historical data generated by the plugin code is still available, but new events for the instruments are not collected.

```
INSTALL PLUGIN plugin_a;
```

The server detects that the 40 instruments are already defined, so no **new instruments are created**, and previously assigned internal memory buffers are reused. The server still has 190 instruments.

```
INSTALL PLUGIN plugin_b;
```

The server has room for 200-190 = 10 instruments (in this case, mutex classes), and sees that the plugin contains 20 new instruments. 10 instruments are loaded, and 10 are discarded or “lost.” The Performance_schema_mutex_classes_lost indicates the number of instruments (mutex classes) lost:

```sql
mysql> SHOW STATUS LIKE "perf%mutex_classes_lost";
+---------------------------------------+-------+
| Variable_name                         | Value |
+---------------------------------------+-------+
| Performance_schema_mutex_classes_lost | 10    |
+---------------------------------------+-------+
1 row in set (0.10 sec)
```
The instrumentation still works and collects (partial) data for plugin_b  

When the server cannot create a mutex instrument, these results occur:
* No row for the instrument is inserted into the setup_instruments table.
* Performance_schema_mutex_classes_lost increases by 1.
* Performance_schema_mutex_instances_lost does not change. (When the mutex instrument is not created, it cannot be used to create instrumented mutex instances later.)

The pattern just described applies to all types of instruments, not just mutexes.

If the value chosen for performance_schema_max_mutex_classes is too small, no error is reported in the error log and there is no failure at runtime. However, the content of the tables in the performance_schema database will miss events. The Performance_schema_mutex_classes_lost status variable is the only visible sign to indicate that some events were dropped internally due to failure to create instruments.

If the server does not have room for all these 1000 instrumented mutexes (instances), some mutexes are created with instrumentation, and some are created without instrumentation. If the server can create only 800 instances, 200 instances are lost. The server continues to run, but increments Performance_schema_mutex_instances_lost by 200 to indicate that instances could not be created.

A value of Performance_schema_mutex_instances_lost greater than 0 can happen when the code initializes more mutexes at runtime than were allocated for --performance_schema_max_mutex_instances=N.

## Performance Schema Atom and Molecule Events

For a table I/O event, there are usually two rows in events_waits_current, not one. For example, a row fetch might result in rows like this:
```
Row# EVENT_NAME                 TIMER_START TIMER_END
---- ----------                 ----------- ---------
   1 wait/io/file/myisam/dfile        10001 10002
   2 wait/io/table/sql/handler        10000 NULL
```

The row fetch causes a file read.

This occurs because, unlike other “atomic” wait events such as for mutexes or file I/O, table I/O events are “molecular” and include (overlap with) other events. In events_waits_current, the table I/O event usually has two rows:

* One row for the most recent table I/O wait event
* One row for the most recent wait event of any kind

## Performance Schema Statement Digests

The digesting process converts a SQL statement to normalized form and computes a hash value for the result. Normalization permits statements that are similar to be grouped and summarized to expose information about the types of statements the server is executing and how often they occur. 

> As of 5.7.4, digesting occurs at the SQL level regardless of whether the Performance Schema is available, so that other server functions such as query rewrite plugins have access to statement digests.

The statement event tables (events_statements_current, events_statements_history, and events_statements_history_long) have columns that contain digests and the corresponding digest hash values:  
* DIGEST_TEXT is the text of the normalized statement digest.
* DIGEST is the digest MD5 hash value.

The maximum space available for digest computation is 1024 bytes by default. As of MySQL 5.7.8, this value can be changed at server startup by setting the performance_schema_max_digest_length system variable.

The statement event tables also have a SQL_TEXT column that contains the original SQL statement. The maximum space available for statement display is 1024 bytes by default. As of MySQL 5.7.6, this value can be changed at server startup by setting the performance_schema_max_sql_text_length system variable. 

** Performance Schema General Table Characteristics

The name of the performance_schema database is lowercase, as are the names of tables within it. Queries should specify the names in lowercase.

Most tables in the performance_schema database are read only and cannot be modified. Some of the setup tables have columns that can be modified to affect Performance Schema operation; some also permit rows to be inserted or deleted. Truncation is permitted to clear collected events, so TRUNCATE TABLE can be used on tables containing those kinds of information, such as tables named with a prefix of events_waits_.

TRUNCATE TABLE can also be used with summary tables, but except for events_statements_summary_by_digest and the memory summary tables, the effect is to reset the summary columns to 0 or NULL, not to remove rows.

Privileges are as for other databases and tables:  
* To retrieve from performance_schema tables, you must have the SELECT privilege.
* To change those columns that can be modified, you must have the UPDATE privilege.
* To truncate tables that can be truncated, you must have the DROP privilege.

## Performance Schema Table Descriptions

### Performance Schema Table Index

|Table Name|Description|
|:---|:---|
|accounts|Connection statistics per client account|
|cond_instances|synchronization object instances|
|events_stages_current|Current stage events|
|events_stages_history|Most recent stage events for each thread|
|events_stages_history_long|Most recent stage events overall|
|events_stages_summary_by_account_by_event_name|Stage events per account and event name|
|events_stages_summary_by_host_by_event_name|Stage events per host name and event name|
|events_stages_summary_by_thread_by_event_name|Stage waits per thread and event name|
|events_stages_summary_by_user_by_event_name|Stage events per user name and event name|
|events_stages_summary_global_by_event_name|Stage waits per event name|
|events_statements_current|Current statement events|
|events_statements_history|Most recent statement events for each thread|
|events_statements_history_long|Most recent statement events overall|
|events_statements_summary_by_account_by_event_name|Statement events per account and event name|
|events_statements_summary_by_digest|Statement events per schema and digest value|
|events_statements_summary_by_host_by_event_name|Statement events per host name and event name|
|events_statements_summary_by_program|Statement events per stored program|
|events_statements_summary_by_thread_by_event_name|Statement events per thread and event name|
|events_statements_summary_by_user_by_event_name|Statement events per user name and event name|
|events_statements_summary_global_by_event_name|Statement events per event name|
|events_transactions_current|Current transaction events|
|events_transactions_history|Most recent transaction events for each thread|
|events_transactions_history_long|Most recent transaction events overall|
|events_transactions_summary_by_account_by_event_name|Transaction events per account and event name|
|events_transactions_summary_by_host_by_event_name|Transaction events per host name and event name|
|events_transactions_summary_by_thread_by_event_name|Transaction events per thread and event name|
|events_transactions_summary_by_user_by_event_name|Transaction events per user name and event name|
|events_transactions_summary_global_by_event_name|Transaction events per event name|
|events_waits_current|Current wait events|
|events_waits_history|Most recent wait events for each thread|
|events_waits_history_long|Most recent wait events overall|
|events_waits_summary_by_account_by_event_name|Wait events per account and event name|
|events_waits_summary_by_host_by_event_name|Wait events per host name and event name|
|events_waits_summary_by_instance|Wait events per instance|
|events_waits_summary_by_thread_by_event_name|Wait events per thread and event name|
|events_waits_summary_by_user_by_event_name|Wait events per user name and event name|
|events_waits_summary_global_by_event_name|Wait events per event name|
|file_instances|File instances|
|file_summary_by_event_name|File events per event name|
|file_summary_by_instance|File events per file instance|
|global_status|Global status variables|
|global_variables|Global system variables|
|host_cache|Information from the internal host cache|
|hosts|Connection statistics per client host name|
|memory_summary_by_account_by_event_name|Memory operations per account and event name|
|memory_summary_by_host_by_event_name|Memory operations per host and event name|
|memory_summary_by_thread_by_event_name|Memory operations per thread and event name|
|memory_summary_by_user_by_event_name|Memory operations per user and event name|
|memory_summary_global_by_event_name|Memory operations globally per event name|
|metadata_locks|Metadata locks and lock requests|
|mutex_instances|Mutex synchronization object instances|
|objects_summary_global_by_type|Object summaries|
|performance_timers|Which event timers are available|
|prepared_statements_instances|Prepared statement instances and statistics|
|replication_connection_configuration|Configuration parameters for connecting to the master|
|replication_connection_status|Current status of the connection to the master|
|replication_applier_configuration|Configuration parameters for the transaction applier on the slave|
|replication_applier_status|Current status of the transaction applier on the slave|
|replication_applier_status_by_coordinator|SQL or coordinator thread applier status|
|replication_applier_status_by_worker|Worker thread applier status (empty unless slave is multi-threaded)|
|rwlock_instances|Lock synchronization object instances|
|session_account_connect_attrs|Connection attributes per for the current session|
|session_connect_attrs|Connection attributes for all sessions|
|session_status|Status variables for current session|
|session_variables|System variables for current session|
|setup_actors|How to initialize monitoring for new foreground threads|
|setup_consumers|Consumers for which event information can be stored|
|setup_instruments|Classes of instrumented objects for which events can be collected|
|setup_objects|Which objects should be monitored|
|setup_timers|Current event timer|
|socket_instances|Active connection instances|
|socket_summary_by_event_name|Socket waits and I/O per event name|
|socket_summary_by_instance|Socket waits and I/O per instance|
|status_by_account|Session status variables per account|
|status_by_host|Session status variables per host name|
|status_by_thread|Session status variables per session|
|status_by_user|Session status variables per user name|
|table_handles|Table locks and lock requests|
|table_io_waits_summary_by_index_usage|Table I/O waits per index|
|table_io_waits_summary_by_table|Table I/O waits per table|
|table_lock_waits_summary_by_table|Table lock waits per table|
|threads|Information about server threads|
|users|Connection statistics per client user name|
|user_variables_by_thread|User-defined variables per thread|
|variables_by_thread|Session system variables per session|
